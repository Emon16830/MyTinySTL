#ifndef ALLOC_H
#define ALLOC_H

#include <cstdlib>
#include <memory.h>

namespace MySTL {
	/*
	* 空间配置器的底层实现
	* 内部
	*/
	class alloc {
	private:
		//enum 枚举创建在类中的常量

		//小型的块区的上调边界
		enum EAlign { ALIGN = 8 };
		//小型的区块的上限 128 Bytes，超过的由 malloc 分配
		enum EMaxBytes { MAXBYTES = 128 };
		//free - lists 的个数 max = 16
		enum ENFreeLists { NFREELISTS = (EMaxBytes::MAXBYTES / EAlign::ALIGN) };
		//每次增加的节点数
		enum ENObjs { NOBJS = 20 };
	private:
		//free - lists 的节点构造
		union obj {
			union obj* next;
			char client[1];
		};
		static obj* free_list[ENFreeLists::NFREELISTS];
	private:

		//内存池起始位置
		static char* start_free;
		//内存池结束位置
		static char* end_free;
		static size_t heap_size;
	private:
		//将bytes 上调至8的倍数
		static size_t ROUND_UP(size_t bytes) {
			return ((bytes + EAlign::ALIGN - 1) & ~(EAlign::ALIGN - 1));
		}
		//根据区块的大小，返回使用第 n 号 free - list ，n从 0 开始
		static size_t FREELIST_INDEX(size_t bytes) {
			return (((bytes)+EAlign::ALIGN - 1) / EAlign::ALIGN - 1);
		}
		//返回一个大小为 n 的对象，并加入大小为 n 的其他区块到 free - list中
		static void* refill(size_t n);
		//配置一大块空间，可容纳 nobjs 个大小为 size 的区块
		//如果配置 nobjs 个区块有所不便，nobjs 可能会降低
		static char* chunk_alloc(size_t size, size_t& nobjs);

	public:
		static void* allocate(size_t bytes);
		static void deallocate(void* ptr, size_t bytes);
		static void* reallocate(void* ptr, size_t old_sz, size_t new_sz);
	};

	//定义 16 个free_list 
	alloc::obj* alloc::free_list[alloc::ENFreeLists::NFREELISTS] = {
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0, 
		0, 0, 0, 0,
	};

	//初始化内存池的位置
	char* alloc::start_free = 0;
	char* alloc::end_free = 0;
	size_t alloc::heap_size = 0;

	//根据 bytes 申请内存
	void* alloc::allocate(size_t bytes) {
		if (bytes > EMaxBytes::MAXBYTES) {
			return malloc(bytes);
		}
		size_t index = FREELIST_INDEX(bytes);
		obj* list = free_list[index];
		//当前list 还有空间留下
		if (list) {
			free_list[index] = list->next;
			return list;
		}
		//当前申请的内存大于128，则需要去内存池中取空间
		else {
			return refill(ROUND_UP(bytes));
		}
	}

	//释放对象所占用的内存空间
	void alloc::deallocate(void* ptr, size_t bytes) {
		// 释放ptr指向的内存空间
		if (bytes > EMaxBytes::MAXBYTES) {
			free(ptr);
		}
		else {
			//index 记录使用第几号链表内存空间
			size_t index = FREELIST_INDEX(bytes);
			//ptr 转为obj ，node 记录
			obj* node = static_cast<obj*>(ptr);
			node->next = free_list[index];
			free_list[index] = node;
		}
	}

	//重新申请内存
	void* alloc::reallocate(void* ptr, size_t old_sz, size_t new_sz) {
		deallocate(ptr, old_sz);
		ptr = allocate(new_sz);
		return ptr;
	}

	//返回一个大小为 n 的对象，且有时候会为适当的 free_list 增加节点
	//此处假设bytes 已经上调为 8 的倍数
	void* alloc::refill(size_t bytes) {
		size_t nobjs = ENObjs::NOBJS;
		//从内存池中取
		char* chunk = chunk_alloc(bytes, nobjs);
		obj** my_free_list = 0;
		obj* result = 0;
		obj* current_obj = 0, * next_obj = 0;
		//取出的空间只够一个对象使用
		if (nobjs == 1) {
			return chunk;
		}
		else {
			my_free_list = free_list + FREELIST_INDEX(bytes);
			result = (obj*)(chunk);
			*my_free_list = next_obj = (obj*)(chunk + bytes);
			//取出多余的空间直接加入对应的 free_list 中
			for (int i = 1;; ++i) {
				current_obj = next_obj;
				next_obj = (obj*)next_obj + bytes;
				if (nobjs - 1 == i) {
					current_obj->next = 0;
					break;
				}
				else {
					current_obj->next = next_obj;
				}
			}
			return result;
		}
	}

	//假设 bytes 已经上调为 8 的倍数
	char* alloc::chunk_alloc(size_t bytes, size_t& nobjs) {
		char* result = 0;
		size_t total_bytes = bytes * nobjs;
		size_t bytes_left = end_free - start_free;
		//内存池当前的剩余空间足够
		if (bytes_left >= total_bytes) {
			result = start_free;
			start_free = start_free + total_bytes;
			return result;
		}
		//内存池剩余空间不能完全满足需求，但是能够供应一个或者以上的区块
		else if(bytes_left >= bytes) {
			nobjs = bytes_left / bytes;
			total_bytes = nobjs * bytes;
			result = start_free;
			start_free += total_bytes;
			return result;
		}
		//内存池剩余空间连一个区块的大小都无法提供
		else {
			size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);
			if (bytes_left > 0) {
				obj** my_free_list = free_list + FREELIST_INDEX(bytes_left);
				((obj*)start_free)->next = *my_free_list;
				*my_free_list = (obj*)start_free;
			}
			start_free = (char*)malloc(bytes_to_get);
			if (!start_free) {
				obj** my_free_list = 0, * p = 0;
				for (int i = 0; i <= EMaxBytes::MAXBYTES; i += EAlign::ALIGN) {
					my_free_list = free_list + FREELIST_INDEX(i);
					p = *my_free_list;
					if (p != 0) {
						*my_free_list = p->next;
						start_free = (char*)p;
						end_free = start_free + 1;
						return chunk_alloc(bytes, nobjs);
					}
				}
				end_free = 0;
			}
			heap_size += bytes_to_get;
			end_free = start_free + bytes_to_get;
			return chunk_alloc(bytes, nobjs);
		}
	}
};
#endif // !ALLOC_H
